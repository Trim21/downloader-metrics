package handler

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strconv"
	"sync"

	"github.com/donovanhide/eventsource"
	"github.com/go-resty/resty/v2"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/utils"
	"github.com/sirupsen/logrus"
	"github.com/valyala/fasttemplate"
)

func setupFloodMetrics(router fiber.Router) {
	os.Setenv("FLOOD_API_USERNAME", "admin")
	os.Setenv("FLOOD_API_PASSWORD", "password")
	os.Setenv("FLOOD_API_ENTRYPOINT", "https://flood.omv.trim21.me/api")

	username, found := os.LookupEnv("FLOOD_API_USERNAME")
	if !found {
		return
	}

	password, found := os.LookupEnv("FLOOD_API_PASSWORD")
	if !found {
		return
	}

	entryPoint, found := os.LookupEnv("FLOOD_API_ENTRYPOINT")
	if !found {
		return
	}

	_, err := url.Parse(entryPoint)
	if err != nil {
		logrus.Fatalf("can't parse FLOOD_API_ENTRYPOINT %s", entryPoint)
	}

	client := resty.New()
	client.SetHostURL(entryPoint)

	res, err := client.R().SetBody(M{
		"username": username,
		"password": password,
	}).Post("auth/authenticate")
	if err != nil {
		logrus.Fatalln("can't connect to flood api", err, res.Request.URL)
	}
	if res.StatusCode() >= 300 {
		logrus.Fatal("can't auth with current flood authorization")
	}

	logrus.Infoln("success login to flood")

	res, err = client.R().SetDoNotParseResponse(true).Get("activity-stream")
	if err != nil {
		logrus.Fatalln("can't stream flood event")
	}

	decoder := eventsource.NewDecoder(res.RawBody())

	v := FloodTransSummary{}
	rw := sync.RWMutex{}
	go func() {
		//
		vv := FloodTransSummary{}
		for {
			e, err := decoder.Decode()
			if err != nil {
				continue
			}
			if e.Event() == "TRANSFER_SUMMARY_FULL_UPDATE" {
				err := json.Unmarshal(utils.UnsafeBytes(e.Data()), &vv)
				if err != nil {
					continue
				}
				rw.Lock()
				v = vv
				rw.Unlock()
			}
		}
	}()

	raw := fmt.Sprintf(`
flood_upload_total{user=%[1]s} [UpTotal]
flood_download_total{user=%[1]s} [DownTotal]

flood_upload_rate{user=%[1]s} [UpRate]
flood_download_rate{user=%[1]s} [DownRate]

`, strconv.Quote(username),
	)

	template := fasttemplate.New(raw, "[", "]")

	router.Get("/flood/metrics", func(ctx *fiber.Ctx) error {
		rw.RLock()
		defer rw.RUnlock()
		s := template.ExecuteString(map[string]interface{}{
			"UpRate":    strconv.Itoa(v.UpRate),
			"UpTotal":   strconv.FormatInt(v.UpTotal, 10),
			"DownRate":  strconv.Itoa(v.DownRate),
			"DownTotal": strconv.FormatInt(v.DownTotal, 10),
		})
		return ctx.SendString(s)
	})
}

type FloodTransSummary struct {
	UpRate    int   `json:"upRate"`
	UpTotal   int64 `json:"upTotal"`
	DownRate  int   `json:"downRate"`
	DownTotal int64 `json:"downTotal"`
}
